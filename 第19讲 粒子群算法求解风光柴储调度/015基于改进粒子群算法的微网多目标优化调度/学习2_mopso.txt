自适应网格搜索的多目标粒子群优化（MOPSO）
CSDN的博主love-study 

置顶 love-study  于 2020-10-19 15:14:42 发布  5433  收藏 43
文章标签： 多目标 粒子群优化 支配关系
版权

进化计算
专栏收录该内容
9 篇文章2 订阅
订阅专栏
此博客中对文档的翻译为博主自己学习时意译的，仅用于学习用途，如有侵权请联系博主删除。如果有不足的地方，欢迎大家评论指出，与博主共同学习。

MOPSO对多目标粒子群优化的一个小建议
这篇文章提出了一个建议是扩展粒子群优化的启发式从而处理多目标优化问题。我们使用了帕累托支配的概念来决定粒子迁移的方向。并且还维持了先前找到的全局非支配向量，最后被其他粒子用来指导他们的迁移。

介绍背景
介绍粒子群
介绍本文提出的方法
类比粒子群优化和进化算法显然知道使用帕累托排序机制可能是扩展的处理多目标优化问题的直接方法。一个粒子找到的最优解的历史记录能用来储存过去产生的非支配解。使用全局吸引机制能促进收敛超全局非支配解收敛。

因此，我们的方法是基于有一个全局存档（储藏室）的概念，每个粒子在每次迁徙循环之后会存储它的迁徙经历。更新档案的方式是由每个粒子的目标函数值确定的基于地理的系统。

MOPSO算法：
1. 初始化种群pop
(a) for i=0:max
(b) 初始化pop[i]

2. 初始化每个粒子的速度
（a） for i=0:max
（b） vel[i]=0

3. 计算种群中每个粒子的适应度值

4.存储每个粒子的位置来代表储藏室REP中的非支配向量

5. 生成目前为止搜索空间开发的超立方体，使用这些超立方体作为一个坐标系系统来定位粒子，每个粒子的坐标都是根据他的目标函数值来确定的。

6. 初始化每个粒子的内存（存储）
（a） for i=0:max
（b） pbest[i]=pop[i]

7.while fes<=fesmax（fes是当前运行次数，fesmax是最大运行次数）
(a) 使用公式计算每个粒子的速度
Vel[i]=wvel[i]+r1(pbest[i]-pop[i])+r2*(REP[h]-pop[i])
W是一个固有（惯性）权重=0.4
R1,r2=rand
Pbest[i]是每个粒子最好的位置
REP[h]是从存档REP中选的值*
角标h的选择方式如下：
这些包含一个以上粒子的超立方体都被分配了一个适应度值=结果除以任何一个大于1的数（包含的粒子数目，实验取10）。目的是为了降低这些包含更多粒子的超立方体的适应度，可以看作是一个适应度的分享形式。然后我们应用轮盘选择来选择从哪个超立方体中选择粒子。最后从被选出的超立方体中随机选择一个粒子。
Pop[i]是粒子i的当前值
(b) 根据速度计算粒子的新位置：
Pop[i] = pop[i]+vel[i]
©使粒子不要超过搜索空间
(d)计算pop中每个粒子的适应度值
(e)用超正方体中的粒子的地理位置做代表，更新REP的内容：
将当前所有非支配解的位置插入到REP中，任何被支配位置都从REP中消失，由于受档案大小的限制，档它满了的时候我们就应用第二准则来保留：这些粒子所处的位置是目标空间中粒子较少的位置比处于粒子集中区域的粒子更优先保留
(f)当粒子当前的位置比内存中的位置好时，粒子的位置就被更新
Pbest[i]=pop[i]
决定内存中什么位置被保留的准则就是应用了帕累托支配（当前的位置被内存中的支配就表留内存中的位置，否则当前的位置就替代内存中相应的位置；如果它们互不支配，我们就中他们中随机选择一个保留）
(g)loop=loop+1；循环数递增

8.end while
算法过程图整理如下：


补充：自适应网格搜索
图中的解释可以理解为当粒子位置超过网格(搜索空间）边界范围时，自动扩大网格边界范围，并重新划分子网格坐标范围。
原文链接如下，有兴趣的小伙伴可以下载来看。
链接: https://pan.baidu.com/s/1S-4XX94-roBco5awIL80jA 提取码: 6n7f 复制这段内容后打开百度网盘手机App，操作更方便哦
————————————————
版权声明：本文为CSDN博主「love-study」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xt_18829518330/article/details/98853043
